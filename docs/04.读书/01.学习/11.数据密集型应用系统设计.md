---
title: 数据密集型应用系统设计
date: 2020-10-18 21:24:23
permalink: /pages/shei5saechaegoo4
categories: 
  - 读书
  - 学习
tags: 
  - 数据密集型
  - 系统设计
---


## 第一章 可靠、可扩展与可维护的应用系统

> 对于一个应用系统，如果“数据”是其成败决定性因素，包括数据的规模、数据的复杂度或者数据产生与变化的速率等，那么可以称之为“数据密集型应用系统”。与之对应的计算密集型，CPU 主频往往是后者最大的制约瓶颈。

### 认识数据系统

- 常见应用系统构成模块
  - 数据库：存储数据，之后再次访问。
  - 高速缓存：缓存复杂或操作代价高昂的结果，加快下一次访问。
  - 索引：用户可以按关键字搜索数据并支持各种过滤。
  - 流式处理：持续发送消息至另一个进程，采取异步方式处理。
  - 批处理：定期处理大量的累计数据。
- 大多数数据密集型系统需要注意到三个问题
  - 可靠性（Reliability）：当出现意外情况如硬件、软件故障、人为失误等，系统应可以继续正常运转，虽然性能可能降低，但确保功能准确。
  - 可扩展性（Scalability）：随着规模的增大，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长。
  - 可维护性（Maintainability）：随之时间的推移，许多新的人员参与到系统开发和运维，以维护现有功能或适配新场景，系统都应高效运转。

### 可靠性

- 系统即使发生了某些错误，系统仍可以继续正常工作。
- 故障通常被定义为组件偏离其正常规格，而失效意味系统作为一个整体停止，无法向用户提供所需的服务。
- 我们不太可能将故障概率降低到零，因此通常涉及容错机制来避免从故障引发系统失败。因此需要我们在不可靠组件基础上构建可靠性系统的相关技术。
- 一般包括如下故障
  - 硬件故障
    - 一般容易想到有：硬盘崩溃，内存故障，电力停电，有人误拔掉网线。
    - 我们第一反应是为硬件添加冗余来减少系统故障率，当一个组件发生故障，冗余组件可以快速接管，之后再更换失效的组件，虽然不能完全放置硬件故障所引发的失效，但是被普遍采用。
  - 软件错误
    - 由于软件错误，导致输入特定值时应用服务器总是崩溃。
    - 一个应用程序使用了某些共享资源如 CPU，没有释放回来。
    - 系统依赖某些服务，但该服务突然变慢，甚至无响应。
    - 级联故障，某个组件的小故障，引发另一个组件的故障。
    - 需要注意
      - 假设条件与系统之间交互，全面测试。
      - 进程隔离，允许进程崩溃，并自动重启。
      - 对于消息队列，消息的幂等性等。
  - 人为错误
    - 如何防止人为错误
      - 以最小出错的方式设计系统，精心设计抽象层、API 以及管理界面。
      - 想办法分离最容易出错的地方、容易引发故障的接口。
      - 充分的测试。
      - 当出现人为失误，提供快速的恢复机制以尽量减少故障影响。
      - 设置详细而清晰的监控子系统，包括性能指标和错误率。
      - 推行管理流程并加以培训。

### 可扩展性

- 可靠性通常包含如下指标
  - 评测负载
    - 对于 Twitter 的主键，以及用户的缓存。
  - 性能
    - 如果负载增加，将会发生什么
      - 负载增加，但系统资源保持不变，系统性能会发生什么变化？
      - 负载增加，如果要保持性能不变，需要增加多少资源？
    - 注意延迟和响应时间的区别？
    - 一个服务涉及多个不同的后端调用，则最慢的调用会拖累整个服务响应时间。
    - 针对特定级别负载而设计的架构不太可能应付超出预设目标 10 倍的实际负载，如果目标服务处理快速增长阶段，那么需要认真考虑每增加一个数据量大 负载，架构应如何设计。
    - 现在谈论更多的是如何在垂直扩展和水平扩展之间做取舍。
    - 把无状态服务分布然后扩展至多台机器相对比较容易，而有状态服务则从单个节点扩展到分布式多机环境的复杂性会大大增加。
  - 延迟百分位数
  - 吞吐量

### 可维护性

- 众所周知，软件的 大部分成本并不在最初的开发阶段，而是在于整个生命周期内持续的投入，这包括维护与缺陷修复，监控系统来保持正常运行、故障排查、适配新平台、搭配新场景、技术缺陷的完美以及增加新功能等。
- 坦白说，每一个遗留系统总有其过期的理由，我们很难给出一个通用的建议该如何处理他们。
- 软件系统的三个设计原则
  - 可运维性：运维更轻松
    - 一个优秀的运行团队至少需要负责
      - 监控系统的健康状况，出现异常及时恢复。
      - 系统故障或性能下降，追踪问题。
      - 保持软件和平台的更新。
      - 了解不同系统之间如何交互影响，避免执行带有破坏性的操作。
      - 预测未来可能的问题，并在问题发生之前既解决。
      - 建立用于部署、配置管理等良好的实践规范和工具包。
      - 执行复杂度维护任务。
      - 当配置更改时，维护系统的安全稳健。
      - 制定流程来规范操作行为，来保持生产环境的稳定。
      - 保持相关的知识传承。
  - 简单性
    - 复杂性的表现方式
      - 状态空间的膨胀
      - 模块之间紧耦合，相互依赖
      - 不一致的命名和术语
      - 为了性能而采取的特殊处理
      - 未解决特定问题而引入的特殊框架
    - 消除意外复杂性最好手段之一是抽象。一个好的设计抽象可以隐藏大量的实现细节，并对外提供干净、易懂的接口。
    - 使用高级的开发语言。
  - 可演化性
    - 最终可以轻松地修改数据系统，使其适应不断变化的需求，这和简单性欲抽象性密切相关。
    - 简单易懂的系统往往比复杂的系统更容易修改。

### 小结

- 一个应用必须完成预期的多种需求，主要包括功能性需求和非功能性需求。
- 功能性需求
  - 应该做什么
  - 存储
  - 索引
  - 检索
  - 处理数据
- 非功能需求
  - 常规特性
  - 安全性
  - 可靠性
  - 合规性
  - 可伸缩性
  - 兼容性
  - 可维护性